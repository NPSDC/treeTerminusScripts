---
title: "Correlation Trees"
author: "Noor Pratap Singh"
date: "4/28/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '/fs/cbcb-lab/rob/students/noor/Uncertainity/treeTerminusScripts')
```

```{r}
suppressPackageStartupMessages(library(SummarizedExperiment))
suppressPackageStartupMessages(library(DESeq2))
suppressPackageStartupMessages(library(ape))
suppressPackageStartupMessages(library(phangorn))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(ggpubr))
suppressPackageStartupMessages(library(cluster))
suppressPackageStartupMessages(library(fastcluster))
suppressPackageStartupMessages(library(HDF5Array))
suppressPackageStartupMessages(library(BiocParallel))
suppressPackageStartupMessages(source("tree_helper_function.R"))
# load("environment/brain_sim_nodtu/mode=gc_bias/post_type=gibbs_nrep=100_tf=100/y.RData")
load("environment/brain_sim_nodtu/mode=gc_bias/mapDf.RData")

tempdir <- "/fs/cbcb-lab/rob/students/noor/RTemp"
setAutoBlockSize(1e9)
setHDF5DumpDir(tempdir)
```

```{r}
UPGMA <- function (D, method = "average", ...) 
{
    DD <- as.dist(D)
    hc <- fastcluster::hclust(DD, method = method, ...)
    result <- as.phylo(hc)
    result <- reorder(result, "postorder")
    result
}

computeInfRV <- function (y, pc = 5, shift = 0.01, rMean=F) 
{
    infReps <- assays(y)[grep("infRep", assayNames(y))]
    infReps <- abind::abind(as.list(infReps), along = 3)
    infMean <- apply(infReps, 1:2, mean)
    infVar <- apply(infReps, 1:2, var)
    assays(y)[["mean"]] <- infMean
    assays(y)[["variance"]] <- infVar
    
    InfRV <- pmax(infVar - infMean, 0)/(infMean + pc) + shift
    if(rMean)
        return(rowMeans(InfRV))
    return(InfRV)
}

colMin <- function(M, arr) {
    ntxps <- nrow(M[[1]])
    D <- matrix(0, ncol = ntxps, nrow = length(M))
    for(j in seq(ntxps)){
        for(i in seq(M)) {
            D[i,] <- M[[i]][j,]
        }
        arr[j,] <<- colMins(D)
    }
}

colMin2 <- function(M, arr, nchunks=10) {
    ###https://stackoverflow.com/questions/2434833/how-can-i-partition-a-vector
    slice<-function(x,n) {
        N<-length(x);
        lapply(seq(1,N,n),function(i) x[i:min(i+n-1,N)])
    }
    ntxps <- nrow(M[[1]])
    sl <- slice(1:ntxps, nchunks)
    D <- matrix(0, ncol = ntxps, nrow = length(M))

    for(k in seq_along(sl)){
        mats <- lapply(seq_along(M), function(i) realize(M[[i]][sl[[k]],]))
        for(j in seq_along(sl[[k]])){
            for(i in seq(M)) {
                D[i,] <- mats[[i]][j,]
            }
            arr[sl[[k]][j],] <<- (1+colMins(D))/2
        }
        
    }
}

cMean <- function(M, arr, nchunks=10) {
    ###https://stackoverflow.com/questions/2434833/how-can-i-partition-a-vector
    slice<-function(x,n) {
        N<-length(x);
        lapply(seq(1,N,n),function(i) x[i:min(i+n-1,N)])
    }
    ntxps <- nrow(M[[1]])
    sl <- slice(1:ntxps, nchunks)
    D <- matrix(0, ncol = ntxps, nrow = length(M))

    for(k in seq_along(sl)){
        mats <- lapply(seq_along(M), function(i) realize(M[[i]][sl[[k]],]))
        for(j in seq_along(sl[[k]])){
            for(i in seq(M)) {
                D[i,] <- mats[[i]][j,]
            }
            arr[sl[[k]][j],] <<- (1+colMeans(D))/2
        }
    }
}
```

#### Creating anti-correlation trees
```{r}
# infReps <- assays(y)[grep("infRep", assayNames(y))]
# infReps <- abind::abind(as.list(infReps), along = 3)
# tInds <- lapply(seq(12), function(i) which(rowSums(infReps[,i,]) == 0))
# rInds <- which(rowSums(assays(y)[["counts"]]) == 0)
# tInds <- Reduce(union,tInds)
# tInds <- union(rInds, tInds)
# infReps <- infReps[-tInds,,]
# #trCorUPGMA <- list()
# 
# corMats <- list()
# for(i in seq(12)) {
#     corTxps <- cor(t(infReps[,i,]))
# 
#     ###Building on anticorrelation
#     #corTxps <- (1-corTxps)/2
#     setHDF5DumpFile(paste(tempdir, paste(paste("cor",i,sep="_"),"hd5",sep="."), sep="/"))
#     setHDF5DumpName(paste("cor",i,sep="_"))
#     setHDF5DumpChunkShape("last-dim-grows-first")
#     setHDF5DumpChunkLength(nrow(corTxps))
#     corMats[[i]] <- as(corTxps, "HDF5Array")
#     rm(corTxps)
#     gc()
#     # dd <- 1-dd
#     # trCorUPGMA[[i]] <- UPGMA(dd)
# }
# 
# arr <- matrix(0, dim(corMats[[1]])[1], dim(corMats[[1]])[1])
# colMin2(corMats, arr, 1000)
# writeHDF5Array(arr, filepath="../../RTemp/min_cor_dist.hd5", name="min_cor_dist")
# arr <- h5mread(filepath="../../RTemp/min_cor_dist.hd5", name="min_cor_dist")
# trMinCorUPGMA <- UPGMA(arr)
# save(trMinCorUPGMA, file="environment/brain_sim_nodtu/mode=gc_bias/post_type=gibbs_nrep=100_tf=100/comp_trees/trMinCorUPGMA.RData")

# 
# trCorUPGMA <- lapply(trCorUPGMA, function(tr) {
#     tr$tip.label <- match(tr$tip.label, rownames(mapDf))-1 ## 0 based
#     tr
# })
# nwks <- lapply(trCorUPGMA, function(tr) write.tree(tr))
# for(n in nwks)
#     write(n, file="/fs/cbcb-lab/rob/students/noor/Uncertainity/terminus/phylip_consensus/inp_tree.nwk",append=TRUE)
# 
# setwd('/fs/cbcb-lab/rob/students/noor/Uncertainity/terminus/phylip_consensus')
# inpComm <- paste(c('echo inp_tree.nwk > input',
#             'echo "R Yes" >> input',
#             'echo "Y"  >> input'), sep="\n")
# system(inpComm)
# consComm <- './consense < input'
# system(consComm)
# rm(corTxps)
# gc()
```

### Loading correlation matrix
```{r}
# corMats <- list()
# for(i in seq(12)) {
#     file <- paste(tempdir, paste(paste("cor",i,sep="_"),"hd5",sep="."), sep="/")
#     name <- paste("cor",i,sep="_")
#     corMats[[i]] <- HDF5Array(filepath=file, name=name)
# }
# arr <- matrix(0, dim(corMats[[1]])[1], dim(corMats[[1]])[1])
# cMean(corMats, arr, 5000)
# writeHDF5Array(arr, filepath="../../RTemp/mean_cor_dist.hd5", name="mean_cor_dist")
# trMeanCorUPGMA <- UPGMA(arr)
# save(trMeanCorUPGMA, file="environment/brain_sim_nodtu/mode=gc_bias/post_type=gibbs_nrep=100_tf=100/comp_trees/trMeanCorUPGMA.RData")
```

#### Computing assays for correlation
```{r}
# trMeanCorUPGMA$tip.label <- rownames(infReps)
# 
# mB <- mergeLeaves(trMeanCorUPGMA, y)
# yR <- mB[["ySwish"]]
# trMeanCorUPGMA <- mB[["tree"]]
# yCorMeanAgg <- prepSwish(trMeanCorUPGMA, yR)
# yCorMeanAgg <- computeInfRV(yCorMeanAgg, meanVariance=F)
# trMeanCor <- trMeanCorUPGMA
# save(trMeanCor, file="environment/brain_sim_nodtu/mode=gc_bias/post_type=gibbs_nrep=100_tf=100/comp_trees/trMeanCor.RData")
# save(yCorMeanAgg, file="environment/brain_sim_nodtu/mode=gc_bias/post_type=gibbs_nrep=100_tf=100/comp_trees/yCorMeanAgg.RData")
```

#### NGenes
```{r}
load("environment/brain_sim_nodtu/mode=gc_bias/post_type=gibbs_nrep=100_tf=100/comp_trees/trMeanCor.RData")
load("environment/brain_sim_nodtu/mode=gc_bias/post_type=gibbs_nrep=100_tf=100/comp_trees/yCorMeanAgg.RData")
nNodes <- length(trMeanCor$tip)+trMeanCor$Nnode
desc <- Descendants(trMeanCor, seq(nNodes))
genesL <- mclapply(desc[length(trMeanCor$tip)+1:trMeanCor$Nnode], function(txps) unique(mapDf[rownames(yCorMeanAgg)[txps],1]), mc.cores=4)
nGenes <- rep(0, nNodes)
nGenes[1:length(trMeanCor$tip)] <- 1
nGenes[length(trMeanCor$tip)+1:trMeanCor$Nnode] <- sapply(genesL, length)

depth <- node.depth(trMeanCor,2)
modDep <- depth
modDep[depth >=7] = 7

df <- data.frame(nGenes = nGenes, modDep = modDep, depth=depth)
pL <- list()
for(i in seq(7)) {
    dfR <- df[df[["modDep"]] == i, ]
    if(i==7) {
        print(sum(dfR[["nGenes"]] > 100))
        dfR <- dfR[dfR[["nGenes"]] <= 100,]
    }
        
    pL[[i]] <- ggplot(dfR, aes(x=nGenes)) +  geom_histogram()     #+facet_wrap(vars(modDep)) 
}
ggarrange(plotlist=pL)
```

### Correlation tree based on count
```{r}
# yM <- y[rowSums(assays(y)[["counts"]])!=0,]
# sf <- DESeq2::estimateSizeFactorsForMatrix(assays(yM)[["counts"]])
# sCounts <- t(t(assays(yM)[["counts"]])/sf)
# corTxps <- cor(t(sCounts))
# corTxps <- as.dist(corTxps)
# save(corTxps, file="environment/brain_sim_nodtu/mode=gc_bias/post_type=gibbs_nrep=100_tf=100/comp_trees/corTxps.RData")
# dd <- (1-corTxps)/2
# rm(corTxps)
# gc()
# ###https://stat.ethz.ch/pipermail/r-devel/2017-June/074488.html
# ###Fast distance euc_dist <- function(m) {mtm <- Matrix::tcrossprod(m); sq <- rowSums(m*m);  sqrt(outer(sq,sq,"+") - 2*mtm)}
# 
# trUPGMA <- UPGMA(dd)
# save(trUPGMA, file="environment/brain_sim_nodtu/mode=gc_bias/post_type=gibbs_nrep=100_tf=100/comp_trees/trUpgma.RData")
```

```{r}
# temp <- mergeLeaves(trUPGMA, y)
# trUPGMA <- temp[[1]]
# yM <- temp[[2]]
# save(yM, file = "environment/brain_sim_nodtu/mode=gc_bias/post_type=gibbs_nrep=100_tf=100/comp_trees/yM.RData")

# yA <- prepSwish(trUPGMA, yM)
# save(yA, file = "environment/brain_sim_nodtu/mode=gc_bias/post_type=gibbs_nrep=100_tf=100/comp_trees/yA.RData")
# load("environment/brain_sim_nodtu/mode=gc_bias/post_type=gibbs_nrep=100_tf=100/comp_trees/trUpgma.RData")
# load("environment/brain_sim_nodtu/mode=gc_bias/post_type=gibbs_nrep=100_tf=100/comp_trees/yM.RData")
# load("environment/brain_sim_nodtu/mode=gc_bias/post_type=gibbs_nrep=100_tf=100/comp_trees/yA.RData")
# infRVCorr <- computeInfRV(yA)
```

<!-- #### Plotting distribution of InfRV  (Mean and Variance) across replicates stratified by depth -->
<!-- ```{r} -->
<!-- infRVSampMean <- rowMeans(infRVCorr) -->
<!-- infRVSampVar <- rowVars(infRVCorr) -->
<!-- depth <- node.depth(trUPGMA,2) -->
<!-- modDep <- depth -->
<!-- modDep[depth >=7] = 7 -->
<!-- dfMean <- data.frame(mean=infRVSampMean, var=infRVSampVar, depth = depth, modDep = modDep) -->

<!-- pL <- list() -->
<!-- ### Plotting mean of infRV across replicates -->
<!-- for(i in seq(7)) { -->
<!--     dfR <- dfMean[dfMean[["modDep"]] == i, ] -->
<!--     pL[[i]] <- ggplot(dfR, aes(x=log10(mean))) +  geom_histogram()     #+facet_wrap(vars(modDep))  -->
<!-- } -->
<!-- ggarrange(plotlist=pL) -->
<!-- ``` -->

<!-- ### Number of genes per level -->
<!-- ```{r} -->
<!-- desc <- Descendants(trUPGMA, seq(nrow(yA))) -->
<!-- nGenes <- rep(0, nrow(yA)) -->
<!-- nGenes[1:nrow(yM)] <- 1 -->
<!-- nGenes[nrow(yM)+1:trUPGMA$Nnode] <- unlist(mclapply(desc[nrow(yM)+1:trUPGMA$Nnode], function(txps) length(unique(mapDf[rownames(yM)[txps],1])), mc.cores=4)) -->
<!-- nGenes <- unlist(nGenes) -->
<!-- df <- data.frame(nGenes = nGenes, modDep = modDep, depth=depth) -->
<!-- pL <- list() -->
<!-- for(i in seq(7)) { -->
<!--     dfR <- df[df[["modDep"]] == i, ] -->
<!--     if(i==7) { -->
<!--         print(sum(dfR[["nGenes"]] > 100)) -->
<!--         dfR <- dfR[dfR[["nGenes"]] <= 100,] -->
<!--     } -->

<!--     pL[[i]] <- ggplot(dfR, aes(x=nGenes)) +  geom_histogram()     #+facet_wrap(vars(modDep))  -->
<!-- } -->
<!-- ggarrange(plotlist=pL) -->
<!-- ``` -->